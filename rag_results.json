[
  {
    "chunk_id": 1,
    "enhanced_content": "4 Why Self-Attention\n\nIn this section we compare various aspects of self-attention layers to the recurrent and convolu- tional layers commonly used for mapping one variable-length sequence of symbol representations (x1,...,%n) to another sequence of equal length (21,...,2n), with x;, 2; € R%, such as a hidden layer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we consider three desiderata.\n\nOne is the total computational complexity per layer. Another is the amount of computation that can be parallelized, as measured by the minimum number of sequential operations required.\n\nThe third is the path length between long-range dependencies in the network. Learning long-range dependencies is a key challenge in many sequence transduction tasks. One key factor affecting the ability to learn such dependencies is the length of the paths forward and backward signals have to traverse in the network. The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn long-range dependencies [12]. Hence we also compare the maximum path length between any two input and output positions in networks composed of the different layer types.\n\nAs noted in Table[I] a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a recurrent layer requires O(n) sequential operations. In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence\n\nlength n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece and byte-pair representations. To improve computational performance for tasks involving very long sequences, self-attention could be restricted to considering only a neighborhood of size r in the input sequence centered around the respective output position. This would increase the maximum path length to O(n/r). We plan to investigate this approach further in future work.\n\nA single convolutional layer with kernel width k < n does not connect all pairs of input and output positions. Doing so requires a stack of O(n/k) convolutional layers in the case of contiguous kernels, or O(log,(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network. Convolutional layers are generally more expensive than recurrent layers, by a factor of k. Separable convolutions [6], however, decrease the complexity considerably, to O(k -n- d+ n-d?). Even with k = n, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer, the approach we take in our model.",
    "metadata": {
      "original_content": {
        "raw_text": "4 Why Self-Attention\n\nIn this section we compare various aspects of self-attention layers to the recurrent and convolu- tional layers commonly used for mapping one variable-length sequence of symbol representations (x1,...,%n) to another sequence of equal length (21,...,2n), with x;, 2; € R%, such as a hidden layer in a typical sequence transduction encoder or decoder. Motivating our use of self-attention we consider three desiderata.\n\nOne is the total computational complexity per layer. Another is the amount of computation that can be parallelized, as measured by the minimum number of sequential operations required.\n\nThe third is the path length between long-range dependencies in the network. Learning long-range dependencies is a key challenge in many sequence transduction tasks. One key factor affecting the ability to learn such dependencies is the length of the paths forward and backward signals have to traverse in the network. The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn long-range dependencies [12]. Hence we also compare the maximum path length between any two input and output positions in networks composed of the different layer types.\n\nAs noted in Table[I] a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a recurrent layer requires O(n) sequential operations. In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence\n\nlength n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece and byte-pair representations. To improve computational performance for tasks involving very long sequences, self-attention could be restricted to considering only a neighborhood of size r in the input sequence centered around the respective output position. This would increase the maximum path length to O(n/r). We plan to investigate this approach further in future work.\n\nA single convolutional layer with kernel width k < n does not connect all pairs of input and output positions. Doing so requires a stack of O(n/k) convolutional layers in the case of contiguous kernels, or O(log,(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network. Convolutional layers are generally more expensive than recurrent layers, by a factor of k. Separable convolutions [6], however, decrease the complexity considerably, to O(k -n- d+ n-d?). Even with k = n, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer, the approach we take in our model.",
        "tables_html": [],
        "images_base64": []
      }
    }
  },
  {
    "chunk_id": 2,
    "enhanced_content": "2 Background\n\nThe goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes it more difficult to learn dependencies between distant positions [12]. In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in sectionB.2]\n\nSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representations\n\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequence- aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence- aligned RNNs or convolution. In the following sections, we will describe the Transformer, motivate self-attention and discuss its advantages over models such as [L and [9].",
    "metadata": {
      "original_content": {
        "raw_text": "2 Background\n\nThe goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions. In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet. This makes it more difficult to learn dependencies between distant positions [12]. In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in sectionB.2]\n\nSelf-attention, sometimes called intra-attention is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence. Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning task-independent sentence representations\n\nEnd-to-end memory networks are based on a recurrent attention mechanism instead of sequence- aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].\n\nTo the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence- aligned RNNs or convolution. In the following sections, we will describe the Transformer, motivate self-attention and discuss its advantages over models such as [L and [9].",
        "tables_html": [],
        "images_base64": []
      }
    }
  },
  {
    "chunk_id": 3,
    "enhanced_content": "3.2.3. Applications of Attention in our Model\n\nThe Transformer uses multi-head attention in three different ways:\n\n¢ In \"encoder-decoder attention\" layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as (38) /2) 9).\n\n¢ The encoder contains self-attention layers. In a self-attention layer all of the keys, values and queries come from the same place, in this case, the output of the previous layer in the encoder. Each position in the encoder can attend to all positions in the previous layer of the encoder.\n\n¢ Similarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out (setting to —oo) all values in the input of the softmax which correspond to illegal connections. See Figure[2|",
    "metadata": {
      "original_content": {
        "raw_text": "3.2.3. Applications of Attention in our Model\n\nThe Transformer uses multi-head attention in three different ways:\n\n¢ In \"encoder-decoder attention\" layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder. This allows every position in the decoder to attend over all positions in the input sequence. This mimics the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as (38) /2) 9).\n\n¢ The encoder contains self-attention layers. In a self-attention layer all of the keys, values and queries come from the same place, in this case, the output of the previous layer in the encoder. Each position in the encoder can attend to all positions in the previous layer of the encoder.\n\n¢ Similarly, self-attention layers in the decoder allow each position in the decoder to attend to all positions in the decoder up to and including that position. We need to prevent leftward information flow in the decoder to preserve the auto-regressive property. We implement this inside of scaled dot-product attention by masking out (setting to —oo) all values in the input of the softmax which correspond to illegal connections. See Figure[2|",
        "tables_html": [],
        "images_base64": []
      }
    }
  },
  {
    "chunk_id": 4,
    "enhanced_content": "This document section focuses on the use of embeddings and the softmax function in sequence transduction models, specifically highlighting the shared weight matrix between embedding layers and the pre-softmax linear transformation. It discusses the conversion of input and output tokens into vectors of dimension \\(d_{model}\\) and the application of a learned linear transformation and softmax function to predict next-token probabilities. The document also includes a detailed table (Table 1) comparing different layer types in terms of complexity per layer, sequential operations, and maximum path length. The layer types analyzed are Self-Attention, Recurrent, Convolutional, and Restricted Self-Attention, with their respective complexities and operational characteristics.\n\nKey Facts and Data Points:\n- Embeddings convert tokens to vectors of dimension \\(d_{model}\\).\n- Shared weight matrix between embedding layers and pre-softmax transformation.\n- Complexity per layer and sequential operations for Self-Attention: \\(O(n^2 - d)\\), \\(O(1)\\).\n- Complexity per layer and sequential operations for Recurrent layers: \\(O(n - d^2)\\), \\(O(n)\\).\n- Complexity per layer and sequential operations for Convolutional layers: \\(O(k \\cdot n \\cdot d^2)\\), \\(O(1)\\).\n- Complexity per layer and sequential operations for Restricted Self-Attention: \\(O(r \\cdot n \\cdot d)\\), \\(O(1)\\).\n\nMain Topics and Concepts:\n- Sequence transduction models\n- Embeddings and vector conversion\n- Softmax function for token prediction\n- Layer complexity and operational efficiency\n- Comparison of Self-Attention, Recurrent, Convolutional, and Restricted Self-Attention layers\n\nQuestions This Content Could Answer:\n- How are embeddings used in sequence transduction models?\n- What is the role of the softmax function in token prediction?\n- How do different layer types compare in terms of complexity and operations?\n- What are the benefits of sharing weight matrices in neural networks?\n\nVisual Content Analysis:\n- Table 1 provides a comparative analysis of layer types, highlighting differences in complexity, sequential operations, and path lengths. This table is crucial for understanding the efficiency and performance of various neural network layers.\n\nAlternative Search Terms:\n- Sequence transduction embeddings\n- Softmax function in neural networks\n- Neural network layer complexity\n- Self-Attention vs. Recurrent layers\n- Convolutional layer operations\n- Restricted Self-Attention efficiency\n\nThis detailed description ensures that users searching for information on embeddings, softmax functions, and neural network layer comparisons can easily find and understand the content.",
    "metadata": {
      "original_content": {
        "raw_text": "3.4 Embeddings and Softmax\n\nSimilarly to other sequence transduction models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension dmode!. We also use the usual learned linear transfor- mation and softmax function to convert the decoder output to predicted next-token probabilities. In our model, we share the same weight matrix between the two embedding layers and the pre-softmax linear transformation, similar to [30]. In the embedding layers, we multiply those weights by V/dmouel-\n\nTable 1: Maximum path lengths, per-layer complexity and minimum number of sequential operations for different layer types. n is the sequence length, d is the representation dimension, k is the kernel size of convolutions and r the size of the neighborhood in restricted self-attention.\n\nLayer Type Complexity per Layer Sequential Maximum Path Length Operations Self-Attention O(n? - d) O(1) O(1) Recurrent O(n - d?) O(n) O(n) Convolutional O(k-n-d?) O(1) O(logx(n)) Self-Attention (restricted) O(r-n-d) ol) O(n/r)",
        "tables_html": [
          "<table><thead><tr><th>Layer Type</th><th>Complexity per Layer</th><th>Sequential Operations</th><th>Maximum Path Length</th></tr></thead><tbody><tr><td>Self-Attention</td><td>O(n? - d)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>Recurrent</td><td>O(n - d?)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>Convolutional</td><td>O(k-n-d?)</td><td>O(1)</td><td>O(logx(n))</td></tr><tr><td>Self-Attention (restricted)</td><td>O(r-n-d)</td><td>ol)</td><td>O(n/r)</td></tr></tbody></table>"
        ],
        "images_base64": []
      }
    }
  },
  {
    "chunk_id": 5,
    "enhanced_content": "1 Introduction\n\nRecurrent neural networks, long short-term memory and gated recurrent [[7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35] [2] [5]. Numerous efforts have sin tinued to push the boundaries of recurrent language models and encoder-decoder architectures\n\nRecurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states h;, as a function of the previous hidden state h,_; and the input for position t. This inherently sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples. Recent work has achieved significant improvements in computational efficiency through factorization tricks and conditional computation [32], while also improving model performance in case of the latter. The fundamental constraint of sequential computation, however, remains.\n\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc- tion models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences . In all but a few cases [27], however, such attention mechanisms are used in conjunction with a recurrent network.\n\nIn this work we propose the Transformer, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output. The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.",
    "metadata": {
      "original_content": {
        "raw_text": "1 Introduction\n\nRecurrent neural networks, long short-term memory and gated recurrent [[7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35] [2] [5]. Numerous efforts have sin tinued to push the boundaries of recurrent language models and encoder-decoder architectures\n\nRecurrent models typically factor computation along the symbol positions of the input and output sequences. Aligning the positions to steps in computation time, they generate a sequence of hidden states h;, as a function of the previous hidden state h,_; and the input for position t. This inherently sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples. Recent work has achieved significant improvements in computational efficiency through factorization tricks and conditional computation [32], while also improving model performance in case of the latter. The fundamental constraint of sequential computation, however, remains.\n\nAttention mechanisms have become an integral part of compelling sequence modeling and transduc- tion models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences . In all but a few cases [27], however, such attention mechanisms are used in conjunction with a recurrent network.\n\nIn this work we propose the Transformer, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output. The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.",
        "tables_html": [],
        "images_base64": []
      }
    }
  }
]